/**
 * SPDX-License-Identifier: MIT
 * @title ZKPVerifier
 * @dev Smart contract for verifying zk-SNARK Zero-Knowledge Proofs
 */
pragma solidity ^0.8.0;

/**
 * @dev Interface for zk-SNARK verifier contract
 * This assumes a precompiled verifier contract generated by a tool like Circom
 */
interface IZKVerifier {
    function verifyProof(
        uint[2] memory a,
        uint[2][2] memory b,
        uint[2] memory c,
        uint[] memory input
    ) external view returns (bool);
}

import "./ZKPVerifierGenerated.sol";

contract ZKPVerifier {
    // State variables
    address public owner;
    address public verifierContract; // Address of the zk-SNARK verifier contract
    
    // Mapping to store verified proofs
    mapping(bytes32 => bool) public verifiedProofs;
    
    // Mapping to store user commitments
    mapping(address => bytes32) public userCommitments;
    
    // Events
    event CommitmentStored(address indexed userAddress, bytes32 commitment);
    event ProofVerified(address indexed userAddress, bytes32 proofId, bool isValid);
    
    // Modifiers
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner can call this function");
        _;
    }
    
    /**
     * @dev Constructor
     * @param _verifierContract Address of the zk-SNARK verifier contract
     */
    constructor(address _verifierContract) {
        require(_verifierContract != address(0), "Invalid verifier contract address");
        owner = msg.sender;
        verifierContract = _verifierContract;
    }
    
    /**
     * @dev Store income commitment
     * @param commitment Cryptographic commitment of income (keccak256 hash)
     * @return success Whether the commitment was stored successfully
     */
    function storeCommitment(bytes32 commitment) public returns (bool success) {
        require(commitment != bytes32(0), "Invalid commitment");
        userCommitments[msg.sender] = commitment;
        emit CommitmentStored(msg.sender, commitment);
        return true;
    }
    
    /**
     * @dev Verify a zk-SNARK proof
     * @param a zk-SNARK proof parameter A (G1 point)
     * @param b zk-SNARK proof parameter B (G2 point)
     * @param c zk-SNARK proof parameter C (G1 point)
     * @param input Public inputs for the proof
     * @return isValid Whether the proof is valid
     */
    function verifyProof(
        uint[2] memory a,
        uint[2][2] memory b,
        uint[2] memory c,
        uint[] memory input
    ) public returns (bool isValid) {
        // Generate a unique proof ID
        bytes32 proofId = generateProofId(msg.sender, a, b, c, input);
        
        // Check if proof was already verified to prevent replay attacks
        require(!verifiedProofs[proofId], "Proof already verified");
        
        // Verify the zk-SNARK proof using the external verifier contract
        isValid = IZKVerifier(verifierContract).verifyProof(a, b, c, input);
        
        // Store the verification result
        verifiedProofs[proofId] = isValid;
        
        // Emit event
        emit ProofVerified(msg.sender, proofId, isValid);
        
        return isValid;
    }
    
    /**
     * @dev Check if a proof has been verified
     * @param proofId ID of the proof
     * @return isVerified Whether the proof has been verified
     */
    function isProofVerified(bytes32 proofId) public view returns (bool isVerified) {
        return verifiedProofs[proofId];
    }
    
    /**
     * @dev Generate a unique proof ID
     * @param userAddress Address of the user
     * @param a zk-SNARK proof parameter A
     * @param b zk-SNARK proof parameter B
     * @param c zk-SNARK proof parameter C
     * @param input Public inputs for the proof
     * @return proofId Unique ID for the proof
     */
    function generateProofId(
        address userAddress,
        uint[2] memory a,
        uint[2][2] memory b,
        uint[2] memory c,
        uint[] memory input
    ) internal view returns (bytes32 proofId) {
        return keccak256(
            abi.encodePacked(
                userAddress,
                a[0], a[1],
                b[0][0], b[0][1], b[1][0], b[1][1],
                c[0], c[1],
                input,
                block.timestamp,
                block.chainid
            )
        );
    }
    
    /**
     * @dev Get user commitment
     * @param userAddress Address of the user
     * @return commitment User's commitment
     */
    function getUserCommitment(address userAddress) public view returns (bytes32 commitment) {
        return userCommitments[userAddress];
    }
    
    /**
     * @dev Update verifier contract address (only owner)
     * @param _newVerifierContract New verifier contract address
     */
    function updateVerifierContract(address _newVerifierContract) public onlyOwner {
        require(_newVerifierContract != address(0), "Invalid verifier contract address");
        verifierContract = _newVerifierContract;
    }
}